# 算法的效率度量

## 1 时间复杂度

### 1.1 事后统计

* 缺点
  1. 和机器性能有关
  2. 和编程语言有关
  3. 和编译程序产生的机器指令质量有关系
  4. 有些算法不能事后统计，如：导弹控制算法

### 1.2 事前统计——时间复杂度

**事前预估**算法**时间开销T\(n\)**和**问题规模n**的关系（T表示“time”）

#### 1.2.1 算法的时间复杂度

![](../../.gitbook/assets/shi-jian-fu-za-du-.png)

#### 1.2.2 一些常用的结论

1. **常对幂指阶**
2. 顺序执行的代码是常数，可以忽略
3. 只需要关注循环里的一条语句执行次数和n的关系即可
4. 多层循环，关注最内层

#### 1.2.3 for

可以参照[C语言的for循环](https://bxg.gitbook.io/language/c/for)

#### 1.2.4 if

含有`if` 的算法，会出现：

* 最好时间复杂度
* 平均时间复杂度
* 最坏时间复杂度

## 2 空间复杂度

### 2.1 内存需求

需要消耗内存的内容

> 如果一个代码的大小是固定的，那么我们称其是原地工作的。

1. 程序代码（编译后的机器指令）：大小固定，与问题规模无关
2. 数据：存放参数、变量、字符串等

